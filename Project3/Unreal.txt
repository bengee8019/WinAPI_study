

▶ 9.20

	언리얼로 어떤 포폴을 만들지 생각하기
	액션, TPS, FPS 추천

	한파트만 제대로 구현되도 인정받는다.
	퀄리티가 나온다는 전제 하에서

	게임 루프

	모작, 창작 상관 없지만
	 모작을 추천, 

======================================================================
	 ※ 엔진이란?

	 라이브러리의 집합체 + 툴, 에디터


	 엔진을 쓰는 이유는?

		ㄴ 개발 기간 단축 (그래픽이 주된 원인) 3D파트에서 수학 물리 범벅
		ㄴ 다이렉트, 불칸 


	 - 그래픽 프로그래밍

	 양대 산맥
		ㄴDX
		ㄴOpenGL

	 DX와 OpenGL의 차이점?
		ㄴ 좌표계 (마야 / 맥스까지도 전부 영향을 받는다.)
			ㄴ 왼손 / 오른손
				ㄴ 차이는 Z축의 진행방향과 X축의 방향

		- 왼손, 오른손 좌표계
				엄지를 기준으로 손목이 굽혀지는 방향으로 +

		ㄴ 기본 베이스는 DX -> 언리얼 / 유니티 -> OpenGL
		ㄴ 월드 좌표에 차이가 발생한다.
			ㄴ SRT/ TRS	(scale, rotation, transform) 적용 순서가 다르다
				배율연산부터 적용되면 나머지에도 영향을 준다.

	★중요!!  렌더링 파이프라인
		ㄴ 쉽게 말해 그리기 위한 일련의 처리 공정 과정이다.

		ㄴ built-in, SRP, URP, HDRP

			built-in	- 커스텀해서 사용할때 쓰는 공정 파트
			SRP			- 코드에 기반해서 돌아가는 파이프라인
			URP			- Unreal 혹은 Unity 렌더링 파이프라인
			HDRP		- High Dynamic Rendering Pipeline	셰이더만 따로 쓰는 파이프라인


			입자기반 파티클은 GPU연산 이미지기반 이펙트는 CPU연산

				ㄴ 9개의 Fixed PipeLine / Programmable PipeLIne

		1. 로컬 스페이스
			ㄴ 디자이너의 영역
				오브젝트의 기본적인 좌표계

		2. 월드 스페이스
			ㄴ 가상의 공간을 만들고 적용을 하기 전 단계 (★★★★★SRT★★★★★)

		3. 뷰 스페이스
			ㄴ 카메라 공간이라고 할 수 있다. 

		4. 백 스페이스 컬링
			ㄴ 보이지 않는 뒷부분을 처리 (엔진에서는 기본적으로 처리를 해준다.)

		★★★★★
		5. 라이트
			ㄴ 조명 최적화의 핵심 중 1개.
			ㄴ 전반사 / 난반사
			ㄴ 종류: Point(점) / Directional(방향성)(태양, 달) / Spot(점적)(가로등느낌) / Ambient(주변)(반딧불이)
				ㄴ 재질: Ambient(주변) / Diffuse(확산) / Specular(반사) / Emissive(방출)


		6. 클리핑
			ㄴ 카메라 영역 밖을 잘라내서 최적화하겠다.

		7. 프로젝션
			ㄴ 3D에서 2D로 변환하는 과정
				크게 2가지 기법이 있다.

				1) Perspective (원근 투영)
					ㄴ 3D
					ㄴ 원근감을 표현하겠다.

				2) Orsographic (직교 투영)
					ㄴ 2D
					ㄴ 원근감 없이(스케일 변형 없이) 바로 투영

		8. 뷰포트
			ㄴ 모니터 화면에 올린다.

		9. 레스터라이즈 (픽셀 보간)
			ㄴ 폴리곤 -> 픽셀
			ㄴ 스크린 좌표로 정점들을 변환하면 폴리곤 정보를 가지게 된다.
			ㄴ 레스터라이즈는 각각의 폴리곤을 출력하는데 필요한 픽셀컬러 값을 계산하는 과정
			ㄴ 기본적으로 컴퓨터가 처리한다.

		-DX		->	윈도우즈
			ㄴ DX 9 / 10 / 11 / 12

			교수님의 추천코스: 9 -> 11 찍고 상황보기


		-OpenGL ->	플랫폼 x (최소 단위의 cpu는 필요하다.)	미쓰비시 엘리베이터 참고하기

		둘다 지원하는 이유 - 다양한 플랫폼에 대한 호환성(DX는 윈도우에 종속성이 있다.)

		-DX 
		ㄴ 장점
			ㄴ

		ㄴ 단점
			ㄴ



▶ 9.21

======================================================================

	ㄴ 아트: 캐릭터, 배경, 액터 등을 제작하고 배치 + 레벨의 비주얼 작업을 하는 사람들
	ㄴ 프로그래밍: 이외 나머지에 대한 처리를 구현하는 사람들
		ㄴ 규모가 커진다면 여기서도 세분화가 많이 되고 작다면 전부다 우리의 몫

	- 기본적으로 엔진을 잘 다룬다는건 아트 + 프로그래밍 영역을 모두 소화할 수 있다는 얘기
		ㄴ 서로 상호보완적인 관계가 있지만 근본적으로 플밍을 잘해야 한다.
			ㄴ TA -> Technical Artist	-	외국으로 나가는 경우가 많다.
			

	- 새로운 지식 + 반복 숙달 (과제) + 샘플 게임

	- 엔진을 잘 쓰고 싶으면 구조 파악이 최우선이다.
		ㄴ C, C++문법이 나온다 싶으면 블루프린트 내부의 구조를 타고 들어가서 확인해보는 과정이 필요하다.
		ㄴ -> 정의된 노드가 나오면 반드시 한번정도 분석을 실행한다.

	▷ 좌표축
		
		- 언리얼 엔진은 기존의 포맷과 좌표축이 다르다.

		- 뷰포트 좌표계는 일반적으로 좌하단을 기준으로 렌더링한다.
		ㄴ 엔진에서도 API가 들어가 있기 때문에 2D/3D 구분 없이 UI를 표현할때는 API좌표계를 사용한다.

		- DX3D (왼손)/ OpenGL(오른손)
		ㄴ 결합 순서 
			ㄴ DX3D: SRT
			ㄴ OpenGL: TRS

		
	★ 기술면접 다발지역
	※ 당장 공부해야 할 것 -> 포폴 전까지
		
		1. 행렬(정방행렬) 	-	행렬간 연산
			ㄴ 3X3	
			ㄴ 4X4	
			ㄴ 역행렬
				ㄴ 간단한 값의 역행렬은 행렬과 단위 행렬이라고 할 수 있지만 복잡한 행렬은 역행렬을 가진다.(거친다. -> 연산량 줄일때)
				ㄴ 필요 없을것 같지만 역행렬이 있기 때문에 로컬 -> 월드 -> 뷰 -> 모니터에서 다시 역순으로 돌아갈 수 있는것.


		2. 벡터
			ㄴ 덧 / 뺄 / 곱( 외적, 내적 )
			
		- 위와 같은 개념을 기반으로 언리얼 엔진은 모든 렌더링을 거칠 때 반드시 셰이더를 거치고 렌더링이 된다.
			(버텍스 자체가 CPU 처리를 해버리면 굉장히 코스트가 많이 들기 때문.)


		- GPU 최우선 -> CPU -> 저장매체 -> 램
			그래도 최적화는 중요하다!!

		언리얼 엔진

		- 장점
		ㄴ 멀티 플랫폼 지원
		ㄴ 통합 개발 환경 지원
		ㄴ 통합 에셋 관리 시스템 지원
		ㄴ 스크립팅 시스템 지원(런 / 에디터)
		ㄴ 파티클 시스템 지원
		ㄴ 2D시스템 지원 (타일 맵, 페이어 2D)
		ㄴ 렌더링 시스템 지원
		ㄴ 셰이더 시스템 지원
		ㄴ 사운드 시스템 지원
		ㄴ 물리 시스템 지원
		ㄴ 지형 시스템 지원
		ㄴ 프로파일링 시스템 지원
		ㄴ 마켓 플레이스 지원
		ㄴ 애니메이션 시스템 지원 (레거시 / 블.스)

		- 단점
		ㄴ 무겁다
		ㄴ 입문 난이도가 높다.
		ㄴ 개발 기간이 길다.
		ㄴ 숙련된 프로그래머가 반드시 필요하다.
		ㄴ 회사 풀이 적다.
		ㄴ 엔진을 활용한 게임 개발이 즐겁지 않다.

		▶ 컴포넌트 프로그래밍?

		- 상속 기반 프로그래밍에서의 단점을 극복하기 위해 나온 프로그래밍 방식
		ㄴ 물체를 1개이상 정의하고 그 물체의 기능을 확장해 나가는 식으로 작업을 하는 개념
		ㄴ 컴포넌트 기반 프로그래밍은 기본적으로 덕 타이핑 개념으로 이해하면 될것 같다.

		◆ 덕 타이핑 (Duck Typing)
		ㄴ 동적 타이핑의 한 종류
		ㄴ 객체의 변수 및 메서드의 집합이 객체의 타입을 결정한다는 뜻

		장점
		ㄴ 유연하다.
		ㄴ 유지보수면에서 아주 훌륭하다.
		ㄴ 설계단계에서 비교적 수월하다.

		단점
		ㄴ 컴포넌트 기반으로 동작을 하기 때문에 이를 엮어줄 기능 / 로직이 반드시 필요하다.
		ㄴ 엮어줄 기능 / 로직이 필요하기 때문에 필연적으로 퍼포먼스 측면에서는 떨어진다.

		▷ 언리얼 엔진에서의 컴포넌트 기반 프로그래밍
		
		- 언리얼 엔진인 컨테이너에 해당하는 게임 객체(Actor)와 EngineCore 클래스를 통해 컴포넌트
		방식을 제어하는 메커니즘을 구현할 수 있다.

		- 커스텀 스크립트 컴포넌트는 반드시 Engine / EngineCore/ CoreMinimal 셋 중 1개를 반드시 받아야
		언리얼 객체에서 지원하는 기능을 활용할 수 있다.

	
	먼저 컨텐츠 브라우저
	All/Game		-> 최상위 루트 ( 잘 기억하자 )

	
	
	디테일
	아웃라이너에서 계층구조 잡는다.



	config - 프로젝트 설정값

	content - 반드시 지켜야 할 폴더

	DerivedDataCache - 로그데이터, 출력데이터, 기록 추적용		프로젝트가 안열릴때 들어가서 확인하는 용도

	Intermediate - 임시 저장파일 

	Saved - 오토 세이브 데이터, 크래쉬 데이터 ( 왜 터졌는지 로그 확인 가능)

	Uproject





	건축 프로젝트 - 언팩한 리소스 타입을 더 다양하게 지원한다.

	과제용 프로젝트와 수업용 프로젝트를 분리해서 관리하자.

	새로운거 할때마다 새 프로젝트

	에셋 이주기능으로 가져오는 방식

	언리얼에서는 폴더 옮기는 것도 위험하다. 미리 만들어서 정리하면서 넣자.




	과제

	아웃라이너 계층 구조 관리를 잘하자
		+ 인스턴스 계층구조 

	과제 1. 에디터 친숙해 지기

		- 오늘 배운 에디터 활용 능력으로 도형을 활용해 모형을 제작한다.
		ㄴ 모형의 종류: 자동차 / 탱크 / 헬리콥터 / 집

		- 색상 및 텍스처는 추가한다.
		ㄴ 오로지 기본 도형으로만 구현한다.

		- 자동차는 바퀴 / 탱크는 상부와 하부 (포탑/ 포신)

		- 헬리콥터는 프로펠러 (2개)

		- 집은 아기자기 배치


▶ 9.22

======================================================================

Light
포함된거 전부

-Light
너 빼고

+Light
정확하게

"Light"
타입


- 용어

유니티: 오브젝트, 컴포넌트

언리얼: 액터 / 폰 / 컴포넌트
ㄴ 액터는 이동 / 회전/ 스케일 같은 트랜스폼만을 가진 오브젝트



★ alt 휠버튼 드래그 -> 피벗 중점 변경

shift f1

f8
빙의


머터리얼

ㄴ Surface에 적용할 수 있는 미리 빌드된 비주얼 이펙트

ㄴ 텍스처 / 색상 / 거칠기 / 빛 등 모든 Surtace 디테일을 감싸는 역할을 한다.


- 전역 조명
셰이더 처리과정 후에 후처리하는식으로 

G파이핑
지축과 그리드가 비슷하게 겹쳐있을 때 서로 먼저 그려지려고 하면서 깜빡거리는 현상
서로 위치를 확실히 구분하거나 -> 테슬버퍼
확실한 우선순위를 준다 -> 덱스버퍼

기본적으로 컨벤셔널을 쓰지만 변수 타입을 앞으로 땡기는 네이밍 방식 추천



블루프린트

노드	
- 나가는 핀이 없으면 최종 노드

핀 종류 2가지

입력핀, 출력핀



metalic
ㄴ 표면이 얼마나 금속같은지 -> 번쩍인다.



하는일은 같으나 정반대의 결과를 가져올 수 있다.

Roughness
ㄴ 언리얼에서 사용. 1에 가까워질수록 거칠어진다.

Smoothness
ㄴ 1에 가까워질수록 매끄러워진다.

컨트롤 알트 -> 드래그 범위 선택

★★★★★ -> 충돌
▶ 메시

- 3D 모델을 구성하는데 가장 중요한 개녕

1. 정점 (Vertex)
	ㄴ 하나의 점 -> 3D 기본단위 
	2D에서의 단순 좌표와는 다르게 다양한 정보가 추가로 포함되어 있다.
	(UV, 법선벡터, 색상 등)


2. 다각형 (Polygon)
	ㄴ 최소한의 면 단위 흔히 삼각형에 비유된다.

	- 정점이 있고 선과 선들이 모여 최소한의 면을 이룬다.

	- 버텍스 3개가 모이면 가장 작은 단위인 면 단위를 이룰 수 있고 이걸 폴리곤이라고 한다.
	

3. 메시 (Mesh)
	ㄴ 메시는 폴리곤이 모여 만들어진 3D 공간상의 물체.

		- static Mesh
			ㄴ 일반적으로 사용하는 메시 외에도 static mesh 라는 객체가 있다.
			ㄴ 말 그대로 정적이라고 이해하면 된다. 고정된 객체
			ㄴ 실시간 연산에서 제외하겠다. -> 성능 챙기기 위해
				-> 실시간 연산 대신에 미리 텍스처 처리를 해놓고 그걸 사용하겠다.

	※ 3D / 그래픽스 파트에서는 특별한 경우(DX에 안들어오는 경우)를 제외하고는 전부 메시를 활용해서 렌더링한다.
		
		각각의 정점에는 vertex shader가 있고
		면에는 Geometric shader가 있다.	-> 버텍스 편집해서 모양을 깎아준다. -> 테셀레이션

		-> 헐 + 구메인
		ㄴ 2D -> 픽셀 셰이더 

	- 지오메트리

		ㄴ 언리얼의 지오메트리는 면 중에 버텍스를 다룬다. -> BSP 렌더링 기법을 사용한다는 얘기.

		◆ BSP: 이진 공간 분할법
		ㄴ 재귀적으로 공간을 평면상의 블록 집합으로 분할하는 기법
		ㄴ 분할 과정에서 BSP 트리라 불리는 트리구조가 형성이 된다.

	▶ UV

	- 텍스처 매핑에 사용되는 좌표계
	ㄴ 백분율로 사용 (0.0 ~ 1.0)
	ㄴ 버텍스의 UV 좌표를 기준으로  텍스처를 펴바른다.


	ex)
		- 하나의 면에 이미지를 붙인다고 가정을 한다면
		ㄴ 이 면은 클수도 있고 작을수도 있다. ( 전체 면을 100, 100)
		ㄴ 이 면에다가 이미지를 붙일건데 50,50으로 붙일 예정
		ㄴ 어떻게 붙일건지에 대한 옵션값이 존재한다.
		ㄴ 포지션, 확대, 축소 등등의 정보가 버텍스에 들어있다.
			포지션: 3D / UV: 2D
				ㄴ 3D 좌표계로 변환 -> 3D 텍스처 큐브맵
			기본적으로 별다른 옵션이 없으면 채우고 확대한다.
			

- 

	과제 1. 지하실 구축

	- 필수: 고퀄리티 제작
	ㄴ 문 3개 이상
	ㄴ 창문 3개 이상
	ㄴ 계단 (일자/나선형)
	ㄴ 방 -> 방에 맞는 오브젝트
	ㄴ 우리가 2일차에 만든 주행 가능한 오브젝트들 격납고



	- 깊이는 지하 3층,

	- 취조실 느낌이 나는 환경을 구축한다.

	- 

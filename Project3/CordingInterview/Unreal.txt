

▶ 9.20

	언리얼로 어떤 포폴을 만들지 생각하기
	액션, TPS, FPS 추천

	한파트만 제대로 구현되도 인정받는다.
	퀄리티가 나온다는 전제 하에서

	게임 루프

	모작, 창작 상관 없지만
	 모작을 추천, 

======================================================================
	 ※ 엔진이란?

	 라이브러리의 집합체 + 툴, 에디터


	 엔진을 쓰는 이유는?

		ㄴ 개발 기간 단축 (그래픽이 주된 원인) 3D파트에서 수학 물리 범벅
		ㄴ 다이렉트, 불칸 


	 - 그래픽 프로그래밍

	 양대 산맥
		ㄴDX
		ㄴOpenGL

	 DX와 OpenGL의 차이점?
		ㄴ 좌표계 (마야 / 맥스까지도 전부 영향을 받는다.)
			ㄴ 왼손 / 오른손
				ㄴ 차이는 Z축의 진행방향과 X축의 방향

		- 왼손, 오른손 좌표계
				엄지를 기준으로 손목이 굽혀지는 방향으로 +

		ㄴ 기본 베이스는 DX -> 언리얼 / 유니티 -> OpenGL
		ㄴ 월드 좌표에 차이가 발생한다.
			ㄴ SRT/ TRS	(scale, rotation, transform) 적용 순서가 다르다
				배율연산부터 적용되면 나머지에도 영향을 준다.

	★중요!!  렌더링 파이프라인
		ㄴ 쉽게 말해 그리기 위한 일련의 처리 공정 과정이다.

		ㄴ built-in, SRP, URP, HDRP

			built-in	- 커스텀해서 사용할때 쓰는 공정 파트
			SRP			- 코드에 기반해서 돌아가는 파이프라인
			URP			- Unreal 혹은 Unity 렌더링 파이프라인
			HDRP		- High Dynamic Rendering Pipeline	셰이더만 따로 쓰는 파이프라인


			입자기반 파티클은 GPU연산 이미지기반 이펙트는 CPU연산

				ㄴ 9개의 Fixed PipeLine / Programmable PipeLIne

		1. 로컬 스페이스
			ㄴ 디자이너의 영역
				오브젝트의 기본적인 좌표계

		2. 월드 스페이스
			ㄴ 가상의 공간을 만들고 적용을 하기 전 단계 (★★★★★SRT★★★★★)

		3. 뷰 스페이스
			ㄴ 카메라 공간이라고 할 수 있다. 

		4. 백 스페이스 컬링
			ㄴ 보이지 않는 뒷부분을 처리 (엔진에서는 기본적으로 처리를 해준다.)

		★★★★★
		5. 라이트
			ㄴ 조명 최적화의 핵심 중 1개.
			ㄴ 전반사 / 난반사
			ㄴ 종류: Point(점) / Directional(방향성)(태양, 달) / Spot(점적)(가로등느낌) / Ambient(주변)(반딧불이)
				ㄴ 재질: Ambient(주변) / Diffuse(확산) / Specular(반사) / Emissive(방출)


		6. 클리핑
			ㄴ 카메라 영역 밖을 잘라내서 최적화하겠다.

		7. 프로젝션
			ㄴ 3D에서 2D로 변환하는 과정
				크게 2가지 기법이 있다.

				1) Perspective (원근 투영)
					ㄴ 3D
					ㄴ 원근감을 표현하겠다.

				2) Orsographic (직교 투영)
					ㄴ 2D
					ㄴ 원근감 없이(스케일 변형 없이) 바로 투영

		8. 뷰포트
			ㄴ 모니터 화면에 올린다.

		9. 레스터라이즈 (픽셀 보간)
			ㄴ 폴리곤 -> 픽셀
			ㄴ 스크린 좌표로 정점들을 변환하면 폴리곤 정보를 가지게 된다.
			ㄴ 레스터라이즈는 각각의 폴리곤을 출력하는데 필요한 픽셀컬러 값을 계산하는 과정
			ㄴ 기본적으로 컴퓨터가 처리한다.

		-DX		->	윈도우즈
			ㄴ DX 9 / 10 / 11 / 12

			교수님의 추천코스: 9 -> 11 찍고 상황보기


		-OpenGL ->	플랫폼 x (최소 단위의 cpu는 필요하다.)	미쓰비시 엘리베이터 참고하기

		둘다 지원하는 이유 - 다양한 플랫폼에 대한 호환성(DX는 윈도우에 종속성이 있다.)

		-DX 
		ㄴ 장점
			ㄴ

		ㄴ 단점
			ㄴ



▶ 9.21

======================================================================

	ㄴ 아트: 캐릭터, 배경, 액터 등을 제작하고 배치 + 레벨의 비주얼 작업을 하는 사람들
	ㄴ 프로그래밍: 이외 나머지에 대한 처리를 구현하는 사람들
		ㄴ 규모가 커진다면 여기서도 세분화가 많이 되고 작다면 전부다 우리의 몫

	- 기본적으로 엔진을 잘 다룬다는건 아트 + 프로그래밍 영역을 모두 소화할 수 있다는 얘기
		ㄴ 서로 상호보완적인 관계가 있지만 근본적으로 플밍을 잘해야 한다.
			ㄴ TA -> Technical Artist	-	외국으로 나가는 경우가 많다.
			

	- 새로운 지식 + 반복 숙달 (과제) + 샘플 게임

	- 엔진을 잘 쓰고 싶으면 구조 파악이 최우선이다.
		ㄴ C, C++문법이 나온다 싶으면 블루프린트 내부의 구조를 타고 들어가서 확인해보는 과정이 필요하다.
		ㄴ -> 정의된 노드가 나오면 반드시 한번정도 분석을 실행한다.

	▷ 좌표축
		
		- 언리얼 엔진은 기존의 포맷과 좌표축이 다르다.

		- 뷰포트 좌표계는 일반적으로 좌하단을 기준으로 렌더링한다.
		ㄴ 엔진에서도 API가 들어가 있기 때문에 2D/3D 구분 없이 UI를 표현할때는 API좌표계를 사용한다.

		- DX3D (왼손)/ OpenGL(오른손)
		ㄴ 결합 순서 
			ㄴ DX3D: SRT
			ㄴ OpenGL: TRS

		
	★ 기술면접 다발지역
	※ 당장 공부해야 할 것 -> 포폴 전까지
		
		1. 행렬(정방행렬) 	-	행렬간 연산
			ㄴ 3X3	
			ㄴ 4X4	
			ㄴ 역행렬
				ㄴ 간단한 값의 역행렬은 행렬과 단위 행렬이라고 할 수 있지만 복잡한 행렬은 역행렬을 가진다.(거친다. -> 연산량 줄일때)
				ㄴ 필요 없을것 같지만 역행렬이 있기 때문에 로컬 -> 월드 -> 뷰 -> 모니터에서 다시 역순으로 돌아갈 수 있는것.


		2. 벡터
			ㄴ 덧 / 뺄 / 곱( 외적, 내적 )
			
		- 위와 같은 개념을 기반으로 언리얼 엔진은 모든 렌더링을 거칠 때 반드시 셰이더를 거치고 렌더링이 된다.
			(버텍스 자체가 CPU 처리를 해버리면 굉장히 코스트가 많이 들기 때문.)


		- GPU 최우선 -> CPU -> 저장매체 -> 램
			그래도 최적화는 중요하다!!

		언리얼 엔진

		- 장점
		ㄴ 멀티 플랫폼 지원
		ㄴ 통합 개발 환경 지원
		ㄴ 통합 에셋 관리 시스템 지원
		ㄴ 스크립팅 시스템 지원(런 / 에디터)
		ㄴ 파티클 시스템 지원
		ㄴ 2D시스템 지원 (타일 맵, 페이어 2D)
		ㄴ 렌더링 시스템 지원
		ㄴ 셰이더 시스템 지원
		ㄴ 사운드 시스템 지원
		ㄴ 물리 시스템 지원
		ㄴ 지형 시스템 지원
		ㄴ 프로파일링 시스템 지원
		ㄴ 마켓 플레이스 지원
		ㄴ 애니메이션 시스템 지원 (레거시 / 블.스)

		- 단점
		ㄴ 무겁다
		ㄴ 입문 난이도가 높다.
		ㄴ 개발 기간이 길다.
		ㄴ 숙련된 프로그래머가 반드시 필요하다.
		ㄴ 회사 풀이 적다.
		ㄴ 엔진을 활용한 게임 개발이 즐겁지 않다.

		▶ 컴포넌트 프로그래밍?

		- 상속 기반 프로그래밍에서의 단점을 극복하기 위해 나온 프로그래밍 방식
		ㄴ 물체를 1개이상 정의하고 그 물체의 기능을 확장해 나가는 식으로 작업을 하는 개념
		ㄴ 컴포넌트 기반 프로그래밍은 기본적으로 덕 타이핑 개념으로 이해하면 될것 같다.

		◆ 덕 타이핑 (Duck Typing)
		ㄴ 동적 타이핑의 한 종류
		ㄴ 객체의 변수 및 메서드의 집합이 객체의 타입을 결정한다는 뜻

		장점
		ㄴ 유연하다.
		ㄴ 유지보수면에서 아주 훌륭하다.
		ㄴ 설계단계에서 비교적 수월하다.

		단점
		ㄴ 컴포넌트 기반으로 동작을 하기 때문에 이를 엮어줄 기능 / 로직이 반드시 필요하다.
		ㄴ 엮어줄 기능 / 로직이 필요하기 때문에 필연적으로 퍼포먼스 측면에서는 떨어진다.

		▷ 언리얼 엔진에서의 컴포넌트 기반 프로그래밍
		
		- 언리얼 엔진인 컨테이너에 해당하는 게임 객체(Actor)와 EngineCore 클래스를 통해 컴포넌트
		방식을 제어하는 메커니즘을 구현할 수 있다.

		- 커스텀 스크립트 컴포넌트는 반드시 Engine / EngineCore/ CoreMinimal 셋 중 1개를 반드시 받아야
		언리얼 객체에서 지원하는 기능을 활용할 수 있다.

	
	먼저 컨텐츠 브라우저
	All/Game		-> 최상위 루트 ( 잘 기억하자 )

	
	
	디테일
	아웃라이너에서 계층구조 잡는다.



	config - 프로젝트 설정값

	content - 반드시 지켜야 할 폴더

	DerivedDataCache - 로그데이터, 출력데이터, 기록 추적용		프로젝트가 안열릴때 들어가서 확인하는 용도

	Intermediate - 임시 저장파일 

	Saved - 오토 세이브 데이터, 크래쉬 데이터 ( 왜 터졌는지 로그 확인 가능)

	Uproject





	건축 프로젝트 - 언팩한 리소스 타입을 더 다양하게 지원한다.

	과제용 프로젝트와 수업용 프로젝트를 분리해서 관리하자.

	새로운거 할때마다 새 프로젝트

	에셋 이주기능으로 가져오는 방식

	언리얼에서는 폴더 옮기는 것도 위험하다. 미리 만들어서 정리하면서 넣자.




	과제

	아웃라이너 계층 구조 관리를 잘하자
		+ 인스턴스 계층구조 

	과제 1. 에디터 친숙해 지기

		- 오늘 배운 에디터 활용 능력으로 도형을 활용해 모형을 제작한다.
		ㄴ 모형의 종류: 자동차 / 탱크 / 헬리콥터 / 집

		- 색상 및 텍스처는 추가한다.
		ㄴ 오로지 기본 도형으로만 구현한다.

		- 자동차는 바퀴 / 탱크는 상부와 하부 (포탑/ 포신)

		- 헬리콥터는 프로펠러 (2개)

		- 집은 아기자기 배치


▶ 9.22

======================================================================

Light
포함된거 전부

-Light
너 빼고

+Light
정확하게

"Light"
타입


- 용어

유니티: 오브젝트, 컴포넌트

언리얼: 액터 / 폰 / 컴포넌트
ㄴ 액터는 이동 / 회전/ 스케일 같은 트랜스폼만을 가진 오브젝트



★ alt 휠버튼 드래그 -> 피벗 중점 변경

shift f1

f8
빙의


머터리얼

ㄴ Surface에 적용할 수 있는 미리 빌드된 비주얼 이펙트

ㄴ 텍스처 / 색상 / 거칠기 / 빛 등 모든 Surtace 디테일을 감싸는 역할을 한다.


- 전역 조명
셰이더 처리과정 후에 후처리하는식으로 

G파이핑
지축과 그리드가 비슷하게 겹쳐있을 때 서로 먼저 그려지려고 하면서 깜빡거리는 현상
서로 위치를 확실히 구분하거나 -> 테슬버퍼
확실한 우선순위를 준다 -> 덱스버퍼

기본적으로 컨벤셔널을 쓰지만 변수 타입을 앞으로 땡기는 네이밍 방식 추천



블루프린트

노드	
- 나가는 핀이 없으면 최종 노드

핀 종류 2가지

입력핀, 출력핀



metalic
ㄴ 표면이 얼마나 금속같은지 -> 번쩍인다.



하는일은 같으나 정반대의 결과를 가져올 수 있다.

Roughness
ㄴ 언리얼에서 사용. 1에 가까워질수록 거칠어진다.

Smoothness
ㄴ 1에 가까워질수록 매끄러워진다.

컨트롤 알트 -> 드래그 범위 선택

★★★★★ -> 충돌
▶ 메시

- 3D 모델을 구성하는데 가장 중요한 개념

1. 정점 (Vertex)
	ㄴ 하나의 점 -> 3D 기본단위 
	2D에서의 단순 좌표와는 다르게 다양한 정보가 추가로 포함되어 있다.
	(UV, 법선벡터, 색상 등)


2. 다각형 (Polygon)
	ㄴ 최소한의 면 단위 흔히 삼각형에 비유된다.

	- 정점이 있고 선과 선들이 모여 최소한의 면을 이룬다.

	- 버텍스 3개가 모이면 가장 작은 단위인 면 단위를 이룰 수 있고 이걸 폴리곤이라고 한다.
	

3. 메시 (Mesh)
	ㄴ 메시는 폴리곤이 모여 만들어진 3D 공간상의 물체.

		- static Mesh
			ㄴ 일반적으로 사용하는 메시 외에도 static mesh 라는 객체가 있다.
			ㄴ 말 그대로 정적이라고 이해하면 된다. 고정된 객체
			ㄴ 실시간 연산에서 제외하겠다. -> 성능 챙기기 위해
				-> 실시간 연산 대신에 미리 텍스처 처리를 해놓고 그걸 사용하겠다.

	※ 3D / 그래픽스 파트에서는 특별한 경우(DX에 안들어오는 경우)를 제외하고는 전부 메시를 활용해서 렌더링한다.
		
		각각의 정점에는 vertex shader가 있고
		면에는 Geometric shader가 있다.	-> 버텍스 편집해서 모양을 깎아준다. -> 테셀레이션

		-> 헐 + 구메인
		ㄴ 2D -> 픽셀 셰이더 

	- 지오메트리

		ㄴ 언리얼의 지오메트리는 면 중에 버텍스를 다룬다. -> BSP 렌더링 기법을 사용한다는 얘기.

		◆ BSP: 이진 공간 분할법
		ㄴ 재귀적으로 공간을 평면상의 블록 집합으로 분할하는 기법
		ㄴ 분할 과정에서 BSP 트리라 불리는 트리구조가 형성이 된다.

	▶ UV

	- 텍스처 매핑에 사용되는 좌표계
	ㄴ 백분율로 사용 (0.0 ~ 1.0)
	ㄴ 버텍스의 UV 좌표를 기준으로  텍스처를 펴바른다.


	ex)
		- 하나의 면에 이미지를 붙인다고 가정을 한다면
		ㄴ 이 면은 클수도 있고 작을수도 있다. ( 전체 면을 100, 100)
		ㄴ 이 면에다가 이미지를 붙일건데 50,50으로 붙일 예정
		ㄴ 어떻게 붙일건지에 대한 옵션값이 존재한다.
		ㄴ 포지션, 확대, 축소 등등의 정보가 버텍스에 들어있다.
			포지션: 3D / UV: 2D
				ㄴ 3D 좌표계로 변환 -> 3D 텍스처 큐브맵
			기본적으로 별다른 옵션이 없으면 채우고 확대한다.
			

- 

	과제 1. 지하실 구축

	- 필수: 고퀄리티 제작
	ㄴ 문 3개 이상
	ㄴ 창문 3개 이상
	ㄴ 계단 (일자/나선형)
	ㄴ 방 -> 방에 맞는 오브젝트
	ㄴ 우리가 2일차에 만든 주행 가능한 오브젝트들 격납고



	- 깊이는 지하 3층,

	- 취조실 느낌이 나는 환경을 구축한다.

	
▶ 9.25		언리얼 4일차

	▶ 블루 프린트

	- 블루프린탄 블루프린트 비주얼 스크립팅 이라고 불리는 노드 기반 스크립팅 시스템

	- 쉽게 접근해 보면 블루프린트는 말 그대로 "비주얼 스크립팅"
		ㄴ 코드로 하는 작업을 노드라는 작업으로 연결시켜주는 것을 의미한다.
		ㄴ 시각적인 그래프 기반 시스템으로 게임 플레이 메카닉이라 인터렉션 로직 구축이 가능하다.

	- 또한 프로그래밍 언어를 잘 모른다 하더라도 게임 플레이에 대한 메커니즘을 만들고 인터페이스를
	구성할 수 있으며 상호작용까지 OK.

	- 블루프린트를 빠르게 마스터하고 C++스크립트로 넘어가는게 엔진에 익숙해지는데 아주 좋다.
		ㄴ 설계 단계 및 모듈화에서도 높은 효율을 자랑한다.

	▷ 블루프린트의 방향

	ㄴ 트랜스폼 + 애니메이션	-> 가장 중요하다. 2가지를 빠르게 익숙해지도록 하자.

	ㄴ 블루프린트 <-> C++ 전환

	- 블루프린트로 포폴을 만들건데 설계의 중요성???

	★ 
	- C++ != C++ Script
		ㄴ 언리얼 => 완벽한 IDE

	-> Script는 간소화되어있다.
		ㄴ 언리얼에 맞게끔 재정의된 스크립트 언어

	▷ 스크립트 언어

	ㄴ 프로그래밍 언어의 한 종류
	ㄴ C# / 자바 / 루비 / 루아 / 파이썬 등등

	- 엔진에서 스크립트 언어는 컴포넌트 종류의 하나일 뿐
	ㄴ 엔진에서 지원하지 않는 기능은 스크립트를 통해 구현할 수 있다.

	- 스크립트 언어는 간이 언어다.
	ㄴ 짧은 명령어로 보는게 맞다.
	ㄴ C / C++에 비해 제한된 기능만 가지고 있지만 비교적 쉽게 프로그램을 작성할 수 있게 한다.
	ㄴ 스크립트 언어의 장점이지만 C++ 스크립트는 해당이 안되니 참고만 하자...


	★ 스크립트 언어의 가장 큰 특징
	ㄴ 인터프리터를 사용한다.

	▷ 인터프리터

	- 일반적인 응용 소프트웨어에서는 컴파일러에 의해 기계어로 번역된 채로 실행이 된다.
		ㄴ 코드의 수정이 빈번하게 발생하면 매번 컴파일을 해야해서 개발 속도가 느리다.
		ㄴ 규모가 큰 프로그램이라면 몇시간 단위로 시간을 소모하고 쉽지않다.

	- 이 때문에 소스 코드를 한 줄씩 읽어서 바로 실행하는 "인터프리터" 방식이 엔진에는 훨씬
		유리하다. (스크립트 언어는 인터프리터를 활용하기 위해 나온 언어.)

	- 언리얼 엔진은 여기서 한 걸음 더 나아가 1. 핫리로드 / 2. 라이브 코딩 기능을 제공한다.

		※ 핫리로드 - 연관된 파트만 컴파일하겠다.

		※ 라이브 코딩 - 런타임 중 코드 수정을 하면 바로 적용된다.

	블루프린트 종류

	- 엔진에서는 다양한 기능 제공을 위해 여러 유형의 블루프린트를 지원한다.
	ㄴ 레벨 / 클래스 / 데이터 / 인터페이스 / 매크로...
	ㄴ 종류가 많아 보이지만 큰 범주는 3가지가 있다.

	- 종류

	1. 레벨
		ㄴ 씬 -> 레벨
			ㄴ 1개만 존재

	2. 클래스
		ㄴ 액터에게 주는 블루프린트
		ㄴ 컴포넌트 기반이라고 생각하면 좋으며 다른 타입의 액터처럼 동작하는 인스턴스 형태로 맵에 배치가 가능하다.


	3. 애니메이션
		ㄴ 애니메이션을 처리하는 블루프린트
		


	※ 언리얼의 다양한 유형

	- 액터
		ㄴ 월드에 배치 가능한 스폰되는 오브젝트

	- 폰
		ㄴ 빙의할 수 있으며 컨트롤러부터 입력을 받는 액터 타입

	- 캐릭터
		ㄴ 걷기 / 달리기 / 점프 등의 기능을 하는 빙의할 수 있는 폰 

	- 컨트롤러(캐릭터)
		ㄴ 플레이어가 사용하는 폰을 컨트롤하는 액터

	- 게임 모드
		ㄴ 게임 플레이를 정의할 수 있는 객체



	1. 속도

	2. 컨벤션
		ㄴ 컬러 스키마
		웬만하면 핀컬러는 바꾸지 말자


	블루프린트로 뭔가를 정의할때는 3가지만 기억하자
	ㄴ 1. 언제(이벤트) / 2. 실행될 조건 / 3. 어떤 행동을 할지

	* Update

	1. Update
		ㄴ 불완전 호출

	2. Fixed Update (물리적 업데이트)
		ㄴ 호출횟수를 고정해서 충돌 등 조건 검출에 안정성을 챙긴다.

	3. Late Update
		ㄴ 카메라 등 (플레이어의 변화에 연동되어 변하는 요소들)


	isHidden
		
		단순히 실행순서를 의미한다.

	▶ 씬 노드

	- 하나의 씬에 있는 노드들을 얘기한다.

	- 하나의 씬에 있는 노드들은 보여질 때가 있고 숨겨질 때가 있다.
	ㄴ 백스페이스 컬링 / 오클루전 컬링 / 프로스텀 컬링 / 페이스 컬링
	ㄴ 최적화의 핵심

	★★★★★★★★★★★★★★★★★★★
	- 드로우콜을 줄일 수 있는 기법


	1. 백스페이스 컬링

	2. 오클루전 컬링
		ㄴ 오브젝트가 다른 오브젝트에 의해 가려져서 카메라 뷰에서 보이지 않을때
			오브젝트 렌더링을 비활성화 하는 기법
		ㄴ 숨겨진 오브젝트를 걸러내며 오브젝트들은 오클루더와 오클루디라는 기법으로 나뉜다.

		- 오클루더
		ㄴ 오클루더 객체들은 미리 Bake된 오브젝트를 가리는 역할을 한다.

		- 오클루디
		ㄴ 오클루더를 통해 가려진 객체들

	- 오클루전 컬링을 할때는 공간을 일정 간격의 셀로 나눠놓고 이를 오클루더가 가리는 영역의 해상도와 맞물려서 
		관리하는 방식 -> 셀의 크기가 작을수록 해상도 UP / 오버헤드 또한 크다.



	3. 프로스텀 컬링(절두체 컬링)
		ㄴ 시야 밖의 오브젝트를 걸러내기 위한 컬링

	4. 페이스 컬링
		ㄴ 찾아보자 

	※ 결론은 부모를 통해서 자식을 컨트롤 할 수 있게 렌더링 하겠다.

		씬 그래프 내부의 씬 노드들



	과제 1. 새로운 스테이지 구축
		
		- 플레이어가 액터를 먹으면 점수가 올라가고
		ㄴ 20점

		- 일정 점수가 되면 게임 클리어 화면으로 전환
		ㄴ 100점

		- 게임 클리어 화면에서는 특정 위치로 가서 다시 게임을 재시작 할 수 있게 해야 한다.


	과제 2. 텍스트와 트리거 박스 원상 복구

		- 현재는 기본적으로 텍스트가 출력이 되면 다시 거리를 둬도 돌아오지 않는다.
		ㄴ 범위를 지정해서 범위 안에 들어가면 나오고 벗어나면 사라지게 만든다.

		- 트리거 박스 역시 충돌에 대한 기능을 온 / 오프로 바꿔본다.
		ㄴ 조건식을 만족하면 되는식으로 만들면 좋다.


	▶ 9.26		언리얼 5일차

	▶ 블루프린트 적응 (문법)

	- 언리얼의 컨벤션?
		ㄴ 전부


		isHidden	-	행위가 파생되는경우
		bHidden

		스트링과 

	 for each 블럭 -> 굳이 따지자면 반복자 느낌쓰
	 
	 배열은 전부 동적배열로 돌아간다.


	 언리얼에서 for 문 쓸 때 주의점 : 탈출 조건에 등호가 들어가있다.

	 for ( int i = First_index; i<= Last_index; i++)
	 {
	 
	 }

	 

	 construction script -> 생성자랑 비슷한 녀석

	 ▶ 머티리얼

	 ㄴ 쉽게 이해하는 방법
	 ㄴ 2D Static 이미지 / 텍스처  ->  머티리얼이다.
	 
	 - 머티리얼 자체는 게임속 환경에 텍스처를 입히거나 SM에 적용하는 경우,
	 여러장의 텍스처를 포함할 수 있다.

	 ※ 언리얼 엔진의 머티리얼 타입

	 - 기본적으로 2가지가 있다.
		ㄴ 이 2가지는 사용용도가 다르다.


	 1. 머티리얼
		ㄴ 실행이 되기전에 한 번만 계산

	 2. 머티리얼 인스턴스
		ㄴ 실행 중 계산을 할 수 있으며 편집도 가능하다.

	- 둘의 큰 차이점은 1. 머티리얼은 유일한 반면 2. 인스턴스는 성능의 큰 비용 없이 여러번 복제가 가능하다.
		ㄴ 2. 머티리얼 인스턴스 같은 경우는 연산 비용이 상대적으로 적은 다형성을 가지는 복제품
		(하이 퀄리티로 가면 당연히 무겁다.)



		a=100;
		testfunction(a, 20);

		
	과제 1. 동전 먹기

	- 탑 뷰에서 진행되는 게임
	ㄴ 미로 형태의 작은 맵

	- 맵에는 코인이 배치되어 있고 코인을 다 먹으면 종료
	ㄴ 전부 모으면 캐릭터에게 스팟 라이트를 비추며 종료.

	- 10개의 코인을 모아야 하며 남은 코인이 5개 이하일 경우 남은 갯수를 알려준다.(로그에 띄워준다.)
	ㄴ 5개 이하일 시 맵의 조명은 전체적으로 어둡게 변경
	ㄴ 남은 코인은 위치를 특정하기 쉽게 각각의 색상이 들어간 조명 + 다이나믹 머티리얼 처리를 하여
		찾기 쉽게

		-맵에 오브젝트로 폭탄도 추가한다.
		ㄴ 폭탄을 먹으면 목표 코인에서 +1



▶ 9.27		언리얼 6일차
	
	레벨 테스트
	ㄴ 선다형 -> 의견을 적는다.

	1. 문제~~~~

	ㄴ 설명:




	제출 : 	워드파일, 문제만 복사해서 아래쪽에 해설 첨부

			


		양식: 이름.zip

		1. 레벨테스트
		2. 용광로


	▶ 시퀀스

	이벤트 -> 시퀀스 -> 여러 행위를 병렬로 실행


	▶ flip flop

	a, b 번갈아서 수행
	is A는 외부에 현재 어떤 코드를 수행중인지 알려주기 위한 boolean
	true -> a,   false -> b

	▶ Gate

	실행 신호가 들어오면 개방, 폐쇄

	▶ Multi Gate



	▶ Do Once
	-> 한번 실행된 후 reset되기 전에는 다시 실행 X

	▶ Do N
	-> N번 실행된 후 reset되기 전에는 다시 실행 X

	▶ ENUM Class
	-> 에디터에서 생성해서 사용 
		-> switch문 붙여보면 알아서 이름 다 들어온다.



	▶ 구조체 Class


	▶ is Valid
		-> 오브젝트가 유효한지 검사

	==nullptr 과 다른점

		오브젝트가 Distroy를 맞으면 
		패링 킬 -> 킬 대기 상태
			ㄴ garbage collection이 돌기를 기다린다.(약 1분에 한번씩 돈다.)

		nullptr로 예외처리하면 패링 킬 상태를 못잡아낸다.
		그렇기 때문에 is Valid로 잡아내자.

	▶ Actor LifeCycle
		- 배치 -> 해제(p.k) -> 레벨에서만 제거 -> 마크업

		라이프 사이클에 영향을 주는 2가지
			- Destroy -> 삭제
			- end Play -> 게임 종료

	언리얼의 Gargage Collector 
		ㄴ 메모리를 관리하는 객체

	1. begin
		ㄴ 마크업이 된 객체들을 체크

	2. 마무리 준비
		ㄴ 정말 날려도 되는지 체크

	3. 소멸 마무리
		ㄴ 지워버리기


	▶ 트랜스폼

	- 이동 / 회전 / 스케일

	- 스크립트 컴포넌트에서 다른 객체 또는 자신 객체에 속해있는
	컴포넌트에 접근하기 위해서는 관련 함수를 써야 한다.

	- 언리얼은 엔진이기 때문에 자주 이용되는 컴포넌트는 미리 프로퍼티로 
	정의가 되어있다. 해당 프로퍼티를 사용하면 쉽게 컴포넌트에 접근할 수 있다.


	프로퍼티

		ㄴ 게터 + 세터를 좀더 편리하게 사용하기 위해 나온 문법
		ㄴ 안정성 + 편리성을 얻을 수 있다.

		- 언리얼의 프로퍼티는 내부 구현이 단순할 경우 이를 자동적으로 정의해주는
		오토 프로퍼티라는 기능을 지원한다.

		- 무명 타입 데이터도 정의할 수 있다.
			ㄴ 지워주겠다. -> 한번 쓰고
			ㄴ 지역변수가 필요하겠다.

	▶ 회전

		1. transform.Rotate
			- 자전

		2. transform.RotateAround
			- 공전
		
		3. transform.AxisRotate
			- 축회전


		오일러 각
			낮은 코스트

			짐벌락 현상


		쿼터니언
			짐벌락이 발생하지 않는다

			직관적이지 않다.

		벡터의 정규화

		- 벡터: 크기와 방향을 가진 데이터 타입
		ㄴ 정규화(단위) 벡터: 벡터의 각 축의 크기가 1인 벡터
		ㄴ 길이가 1인 벡터

		- Vector3(1,0,0)	-> Vector3.right
		- Vector3(-1,0,0) -> Vector3.left
				
		- Vector3(0,1,0)	-> Vector3.up
		- Vector3(0,-1,0) -> Vector3.down
				
		- Vector3(0,0,1)	-> Vector3.foward
		- Vector3(0,0,-1) -> Vector3.back
				
		- Vector3(0,0,0)	-> Vector3.zero
		- Vector3(1,1,1) -> Vector3.one

		- Vector3.Dot					내적
		- Vector3.Cross					외적
		- Vector3.Distance				-> A / B 벡터의 거리를 알려준다.
		- Vector3.Angle					-> A / B 벡터의 각도 차이를 degree로 알려준다.
		- Vector3.Normalize				-> 정규화 시켜주는 인스턴스 함수
		- Vector3.Magnitude				-> 벡터의 길이를 구해준다.
		- Vector3.SqrMagnitude			-> 길이 제곱을 구해주는 함수

		- Axis 
			ㄴ 축을 의미하기 때문에 프로퍼티가 존재하고 GET / SET

			- GetAxis / GetAxisRaw 차이점

			ㄴ GetAxis: 실수
				부드러운 움직임

			ㄴ GetAxisRaw: 정수
				즉각적인 반응이 필요할 때

			둘의 공통점은 -1 ~ 1까지의 값을 사용한다.


		foward, right 기준으로 사용
		반대는 음수값 넣어서

		트랜스폼 고려할 점
		ㄴ 1. 부모 기준? (계층구조를 따르겠다.)/ 내 기준? (계층 구조 X)
		ㄴ 2. 로컬 좌표? / 월드 좌표?
		ㄴ 3. 단발성인지 (변이량 누적 X) / 지속성인지? ( 변이량 누적 O)
		ㄴ 4. 함수를 이용할건지? / 프로퍼티를 이용할건지? / 객체를 찾아보고 컴포넌트를 이용할지?
		ㄴ 5. 어떤 이벤트로 처리를 할건지? (EX : 키, 조건 만족 등등)



		
		과제 1. 레벨 테스트 (일요일 제출)
		
			- 양식 + 제출기한은 따로 공지하겠음

			- 1. 레벨 테스트 (워드) => 프로젝트 포함해서 제출

			- 2. 구현을 목표로 하는 샘플 => 3가지 모두 압축해서 제출

			ㄴ 최종적으로 제출할 파일은 1개 (1+2 묶어서)



		과제 2. 트랜스폼 활용 

		- 4종 객체에 트랜스폼을 적용한다.


			- 1. 일자형 트랙이 있고 트랙의 양끝에서 자동차 2대가 마주보고 달려온다.
				ㄴ 두 객체가 충돌하면 튕겨 나가거나 밀리게 만드는 물리 법칙을 적용한다.
					ㄴ 충돌 이벤트에서 답을 찾을 수 있다.
					ㄴ 자동차는 움직일 때 바퀴는 회전을 해야 한다.

			- 2. 헬기는 직접 조종을 하며 움직일때는 프로펠러가 회전을 하고 계속 움직여야 한다.
				ㄴ 큰 프로펠러 + 작은 프로펠러

			- 3. 탱크도 직접 조종을 할 수 있으며 상부와 하부가 따로 움직여야 한다.
				ㄴ 포신 부분과 차체 부분은 실제 탱크처럼 360도 회전을 한다.
				ㄴ 포신은 조준이 가능하게 구현

			- 4. 집 주위를 지키는 도형 가드를 만든다.
				ㄴ 패턴 5종 이상 -> 트랜스폼만을 활용해서


10.04


스태틱
	움직이지 않는 매쉬. 미리 메모리에 넣어놓을 수 있기 때문에 렌더링이 가장 빠르다.

스테이셔너리


무버블




 틱 업데이트 vs 델타 타임

 업테이트 : 한프레임에 1번 갱신

 델타타임: 게임 플레이 프레임들 사이의 시간 (사이 시간에 한번씩)


 ▶ 충돌 체크

 - 언리얼에서는 충돌을 감지하기 위해 다양한 오브젝트타입에 따라
 일반화된 혹은 단순한 코리전을 지원을 한다.

 - 단순 구 콜리전
	ㄴ 총알

 - 단순 캡슐 콜리전
	ㄴ 플레이어

 - 박스 콜리전
	ㄴ 트리거

 - ★ 메시 콜리전
	ㄴ 정밀도는 높으나 무겁다. 


	▷ 언리얼 블루프린트 형변환

	- 부모와 자식의 관점에서 생각할 수 있다.

	- 블루프린트 내의 액터는 서로 간의 부모가 될 여지가 있다.
		ㄴ 각각의 자식들이 다른 속성을 상속하는 계층 구조를 가질 수 있다는 말.

	EX) 1. 차량이 있다. -> 메인 액터 -> 차량 액터에는 가속 / 감속 / 브레이크 등의 파라미터가 있다.

		2. 바퀴 2개 또는 바퀴 4개의 2가지 자식 액터의 속성이 다르다.

		3. 이륜 -> 기어가 있다./ 사륜도 기어가 있다.
			ㄴ 그럼 이 둘의 기어는 같은 기어인가?
				다른놈이라면 내가 상속받는 혹은 상속을 주는 액터에 따라서 내 속성이 바뀐다.

			라이브 코딩시 맥락읽어서 띄워주는 노드는 상속이 쌓여있는 걸로 결정된다.

		델리게이트

11월달 모의 면접




과제 1. 실린더 응용 과제
	
	- 현재 실린더는 총알에 맞으면 색이 바뀐다.

	- 1. 다시 총알을 맞추면 색상을 바꾼다.
		ㄴ RGB 순으로

	- 2. 실린더가 10회 이상 총알과 충돌이 되면 실린더의 색을 검정색으로
		ㄴ 2번 상태로 전환이 되면 실린더는 공중에서 회전( 회전 방식은 상관 없음 )

	- 3. 검정색이 된 실린더는 10초 후에 다시 리셋되면서 원래 색상으로 돌아오고 다시 충돌처리가 가능해진다.



10.05

▶ 포트폴리오 중점 사항

- 때깔이 가장 중요하다.

	- 활용 능력
	
	- 구현 능력
	
	- 리소스 접근성


===============================================
- 움직임을 주고 싶다.
	ㄴ 1. 트랜스폼 (정석)
	ㄴ 2. 엔진에서 지원하는 방법 사용
		ㄴ 타임라인 - 트랜스폼에 관련된 노드는 아님(원래는 애니메이션 용도)

		불규칙적인 운동을 구현할때는 무조건 1번

		규칙적인 운동을 구현할 때 타임라인을 이용하면 편하다.
		
◆ 타임라인 : 주로 애니메이션을 통한 자연스러운 움직임을 표현할 때 사용한다.
			ㄴ 특수 노드로써 엔진에서 사용할 수 있는 부드러운 처리에는 
				모두 적용할 수 있다고 생각하면 된다.  (리버스 기능때문에 유용하다)

	- 언리얼 엔진 애니메이션
		
		- 크게 2가지가 있다.
		ㄴ 1. 타임라인
		ㄴ 2. 애니메이션 블루프린트 (마티네)

		타임라인: 간단한 값에 변화를 주기에 적합하다.
		애니메이션BP: 캐릭터 기반의 애니메이션이나 시네마틱을 위한 애니메이션을 다룰 때 적합,
						스켈레탈 메시의 애니메이션을 제어할 수 있는 기능들을 제공.(특수BP)

	▶ 보간

	- 수치해석학의 한종류
	ㄴ 각 데이터의 사이값을 구하는 방법
	ㄴ 선형 / 구면 / 포물선 / 다항식 / 스플라인 등이 있다.

	선형 / 이중 선형 / 구면 보간까지만 알면 지장이 없다.

	- Lerp의 종류


	선형 보간(위치 벡터 기반)
	- Mathf.Lerp		실제 구현해서 보간하겠다.
	- Vector2.Lerp		
	- Vector3.Lerp		
	- Quaternion.Lerp	


	구면 보간(방향 벡터 기반)
	- Mathf.SLerp	
	- Vector2.SLerp	
	- Vector3.SLerp	
	- Quaternion.SLerp

	EX) 
	- Vector3.Lerp(위치1, 위치2, 0)
	- Vector3.Lerp(위치1, 위치2, 0.5f)
	- Vector3.Lerp(위치1, 위치2, 1)		

	직교 
	- 두 벡터 사이의 각도가 90도를 이루는 상태를 직교한다고 한다.
		ㄴ 수직 벡터

	RPY -> x y z 축
	Roll	Pitch	Yaw

	▶ 디스트럭터블 메시 (언리얼 4)

	- 원래 기본 내장된 기능이었으나 플러그인으로 빠짐.
	ㄴ 플러그인 이름 : Apex Destruction

	언리얼 5 에서는 카오스 디스트럭션으로 이름이 바뀌었다.


	과제 1. 사격장 구현 

	- 필수: 타겟 3종 + 스테이지 2개 + 점수 시스템 + 시간
	ㄴ 타겟은 총알에 맞으면 넘어가는 놈 / 깨지는 놈 / 제자리에서 내려가는 놈 -> 총 3개

	- 스테이지는 2개 - 점수 시스템은 로그를 찍고 사격이 종료되면 획득 점수를 로그로 표시한다.
	
	- 제한 시간은 60초, 재시작 기능 필수

	참고 -> 바이오하자드 4 RE 사격장 / 이블위딘 2 사격장


10.06

	▶ UI

	-2D / 3D가 구조적으로 다르다
	ㄴ GUI / HUD

	- UI는 유저 인터페이스의 줄임말 -> 상호작용을 하기 위해 필수로 필요한 시스템
		ㄴ CLI -> TUI -> GUI 형태로 발전이 됐다.
		ㄴ 현재는 대부분 GUI로 구성을 하고 있는 시장 상황

	- 언리얼쪽은 GUI 에디터를 채용하고 있으며 이 GUI에디터에 TUI + GUI 혼합된 형태로 지원을 한다.
		-> UMG

	* UMG 언리얼 모션 그래픽 UI

	UI 파트는 코드보다 BP가 더 효율적이다.

	- 언리얼 엔진에서 지원하는 모션 그래픽 비주얼 툴
		ㄴ 메뉴 / HUD / 대부분의 UI를 구현할 수 있게 기능적으로 지원을 한다.

	※ 엔진의 UI 구조는 캔버스라는 오브젝트를 부모삼아 부모 아래에 UI객체를 정립하는것으로 시작이 된다.
		UI 구조는 트리 구조를 따라간다. -> 중요!!

	- 언리얼에서 지원하는 UI는 크게 4가지 유형을 가진다.
		(종류별 UI 레이아웃이 이미 정해져 있기 때문에 구분해서 사용하는게 좋다.)

		- 논다이제틱
			ㄴ 나만 볼 수 있는 UI
				ex) 메뉴 / 크로스헤어 등등

		- 다이제틱
			ㄴ 흔히 경험과 연결되는 UI라고 할 수 있다. (이벤트)
				ex) 내가 게임내에서 버튼을 누르면 미사일 나간다.

		- 스파셜
			ㄴ 지오메트리내의 3D공간에 표시되는 UI
				ex) 진행 방향 화살표 등
		
		- 메타
			ㄴ 이벤트의 추상적 표현으로 표시되는 UI (알파값 표현에 특화되어있다.)
				ex) 플레이어가 체력이 떨어지면 표현되는 혈흔 효과


	- GUI
		ㄴ 위의 4가지 개념을 통칭해서 부르기도 하며 게임내에 표현되는 대부분의 UI를 표현하는 객체

	- HUD (Heads Up Display)
		ㄴ 정적 디스플레이 -> 상호작용 없이 정보만 표시하는 UI


		float은 초기값 1 백분율로 표현하기위해

		레벨 블루프린트에서 destroy actor가 들어가는 경우 레벨에서 처리하는게 맞는지 한번 더 생각해보자.
		가비지 콜렉터가 더 깊게 파고들 수 있기 때문 ( 단발성으로 밀어버릴 수 있는지 확인해보자 )

		BP에서는 최대한 단순하게 구현하는게 좋다.


		우상단 그래프 아이콘 -> 전역 블루 프린트
			tick쓰는건 최대한 자제하자

		construct 이벤트 -> 멤버 이니셜라이저
			생성자와는 다르다.

		보라색 construct함수 -> 생성자

		beginplay와 생성자
		



과제 1. 플레이어 무장 추가

	- 플레이어에게 3종의 무장을 추가한다.

	- 게임이 시작되고 특정 위치에 가면 무기를 선택할 수 있게 구현한다.

	- 무기를 선택하고 5초 뒤부터 레벨에는 무작위 위치에 선택하지 않은 무기가 스폰된다.

	- 새로운 무기를 획득하면 무기가 교체된다.

	- 무기에 따른 새로운 탄약 유형을 만든다.

	- 게임이 시작되고 30초가 지나면 총 소켓이 추가되어 내가 소지할 수 있는 총 무기의 개수를 2가지로 늘린다.
		ㄴ 1, 2번으로 무기 스왑이 가능하도록

	- 각 무기에 맞는 특징 / 사운드 / UI 요소까지 구현을 원칙으로 한다.

	- 구현 목록
		ㄴ 1. 샷건
		ㄴ 2. 스나이퍼
		ㄴ 3. 유탄발사기
		ㄴ 4. 레이저

	다음주 중에 포폴 기획서 ppt 제출

		
▶ AI -> 애니메이션

- 3D 월드에서 AI가 맵을 돌아다니게 하려면 터레인 / NavMesh / Navigation 정보가 필요하다.
	ㄴ 맵에다가 위의 3종 중 하나를 심어준다.

	◈ Navigation
	
		- 상용 엔진에서 게임 오브젝트가 길을 찾을 때 사용한다.
			ㄴ 라이트맵과 유사한 구조를 가진다.
			ㄴ 미리 Bake를 진행하고 시작하기 때문에 길찾기 로직 치고는 그나마 가볍다.
				ㄴ 단 맵의 크기가 커지거나 오브젝트가 많아지면 부하가 발생하기 시작한다.


	◈ NavMesh


		- Navigation Mesh의 줄임말

		- 맵을 구성하는 3D 오브젝트의 Mesh 정보를 분석하여 추적할 수 있는 영역과 장애물로 판단해 지나갈 수 없는
		영역의 데이터를 미리 만들어둔다.

		- 이후 Bake하여 네비게이션 정보를 생성하고 그를 바탕으로 객체가 움직인다.

		- NavMesh 같은 경우는 레벨당 1개 / 2개 정도가 적당하다. -> 남발하면 최적화 실패


	위처3의 경우는 ASTAR사용 - 무겁지만 캐릭터 근방 6M 정도의 반경만 검사하는식으로 사용.
	Navigation, NavMesh도 이렇게 쓴다면 가능하다.
	3d에서는 다익스트라가 많이 사용된다.



	▶ AI 로직을 구현하기 위한 객체들 (기능들)

	- 언리얼에서 지원하는 고급 AI 기능 (아래 3가지는 주로 세트로 사용한다.)

	1. Behavior Tree(행동 트리)
		ㄴ 적 캐릭터의 의사결정에 필요한 로직을 관리한다.
			어떤 조건에 어떤 액션을 취할 것인지??
			커스텀 애니메이션까지 붙이면 ->  ▣ FSM ▣

	2. AI Controller
		ㄴ 캐릭터와 행동 트리를 연결하는 중간다리 역할을 한다.
			행동 트리에서 만들어진 정보와 액션을 캐릭터에게 전달해 액션이 실행되도록 한다.

	3. BlackBoard
		ㄴ 행동트리에서 사용되는 모든 데이터를 담고 있는 컨테이너 (뇌)



	◈ Pawn(폰)
	ㄴ 액터의 서브 클래스로 폰 클래스는 플레이어나 AI가 제어할 수 있는
		모든 액터의 베이스 클래스라고 할 수 있다.
	ㄴ 폰은 플레이어 또는 NPC 형태로 게임의 AI 제어를 받을 수 있다는 점이 액터와의 차이점이다.



	★★★★★	
	▶ 행동 트리 분기

	# 분기 노드

		1. 셀렉터
			
			- 아래쪽으로 연결된 모든 노드를 실행한다.

			- 아래쪽으로 연결된 노드들은 자식이라고 하며 왼쪽부터 오른쪽 방향으로 실행이 된다.

			★ 실행된 자식이 성공적으로 실행됐다면 그곳에서 실행을 멈추고 다음 노드를 실행하지 않는다.
				ㄴ 왼쪽부터 시작해서 한 번 실행에 성공할때까지만

		2. 시퀀스
			
			- 셀렉터와는 반대로 실행되며 모든 자식을 왼쪽 -> 오른쪽으로 실행

			★ 하나의 자식이라도 실행에 실패하면 실행을 멈추고 시퀀스를 중지.


		3. 태스크 노드

		- 시작적으로 행동의 결과를 가져오는 노드

		- 행동 트리에서 가장 아래쪽에 위치하며 행동의 결과를 의미하기 때문에 아래쪽으로 더이상 노드를 추가할 수 없다.





	과제1. 정찰 경로 개선

		- 정찰 포인트를 6개 설정한다.

		- 1번 정찰 포인트부터 4번 정찰 포인트까지는 통상적인 정찰을 수행하며 4번이후로는 AI가 5,6번 포인트를 임의로 선택해 움직일 수 있다.

			1. 5번으로 갈시 6번을 반드시 거쳐야 하며 6번드로가면 다시 4번으로 돌아와야 한다.

			2. 이후에는 역순으로 루틴이 반복되며 한 사이클이 끝날때마다 1번부터 시작해서 정찰 포인트를 삭제한다.

			3. 최종적으로는 5,6번만 남게 되고 5번과 6번을 번갈아 가며 정찰을 하는 형태로 구현

			enemycontroller 에서 처리가 필요할것임.


10.11

	※ PawnSensing	-> 폰 자체에 감각을 부여하는 방식

	- 기본적인 이벤트 외에 추가적인 이벤트 트리거를 제공하는 컴포넌트
		ㄴ 폰의 감각 컴포넌트라고 불리며 액터의 감각 설정과 기능을 담은 집합체라고 할 수 있다.

	※ EQS	-> 환경에 심어놓는 방식
		
	- 노드를 환경에 심어놓고 폰이 인식할 수 있는 범위의 노드에 플레이어가 있는지 체크, 실시간으로 연산이 발생하여 무겁다.


	※ 델리게이트

	- 액터 레벨에서는 상대적으로 사용이 적지만 폰 레벨로 올라오면 사용빈도가 올라간다.

	- 델리게이트를 이용하면 멤버 변수를 보관하고 호출하는 것이 가능하며
		함수를 함수의 반환 값 또는 매개변수로 전달하는 것이 가능하기 때문에 유용하다.

	- 델리게이트는 값 / 참조로 모두 전달이 가능하지만 메모리 할당 (힙)을 해야 하기 때문에 가급적
		참조로 전달하는 것이 좋고 이런식으로 구현을 해야 체인을 사용할때도 무리가 없다.


	- 델리게이트는 멤버 함수를 가르키고 있는 자료형
		ㄴ 콜백 함수
			ㄴ 특정 이벤트가 발생하는 시점에 해당 이벤트를 처리한다.


	※ 언리얼 델리게이트
	
	- 언리얼 델리게이트는 무명함수를 정의할 수 있다.
	
	- 싱글 / 멀티 모두 지원.

	- 디스크에 안전하게 시리얼라이즈 시킬 수 있는 다이나믹 델리게이트 또한 지원한다.

		- 싱글
	
		- 멀티
	
		- 이벤트
	
		- 다이나믹 (캐스팅 (Object / Serialize))

	
	시퀀서 Sequencer


